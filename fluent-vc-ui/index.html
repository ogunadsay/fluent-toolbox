<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Catalogue Network Location Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        #visualization {
            width: 100%;
            height: 900px;
            border: 1px solid #ccc;
            overflow: auto;
        }
        .node {
            position: absolute;
            overflow: hidden;
            border: 1px solid #fff;
            box-sizing: border-box;
            font: 10px sans-serif;
            transition: opacity 0.5s;
        }
        .node:hover {
            opacity: 0.9;
        }
        .node-label {
            position: absolute;
            padding: 4px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            pointer-events: none;
        }
        .root { background-color: #333; }
        .retailer { background-color: #fd8d3c; }
        .virtualcatalogue { background-color: #74c476; }
        /* Network colors will be assigned dynamically */
        .location { background-color: #6baed6; }
        
        .tooltip {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 14px;
            max-width: 300px;
            z-index: 1000;
        }
        
        .collapse-indicator {
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            background-color: rgba(0,0,0,0.3);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            line-height: 20px;
            text-align: center;
        }
        
        .node--has-children {
            cursor: pointer;
        }

        /* Added styles for input section */
        .input-section {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #json-input {
            width: 100%;
            height: 200px;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 8px 16px;
            background-color: #0d6efd;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #0b5ed7;
        }
        
        #reset-btn {
            background-color: #dc3545;
        }
        
        #reset-btn:hover {
            background-color: #bb2d3b;
        }
    </style>
</head>
<body>
    <h1>Virtual Catalogue Network Location Visualizer</h1>
    
    <!-- Added input section -->
    <div class="input-section">
        <textarea id="json-input" placeholder="Paste your JSON data here..."></textarea>
        <div class="button-group">
            <button id="visualize-btn">Visualize</button>
            <button id="reset-btn">Reset</button>
        </div>
    </div>

    <div id="visualization"></div>

    <script>
        // Store network colors for consistency
        const networkColors = {};
        
        // Generate a random color
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        
        // Get color for a specific network ID
        function getNetworkColor(networkId) {
            if (!networkColors[networkId]) {
                networkColors[networkId] = getRandomColor();
            }
            return networkColors[networkId];
        }
        
        // Initialize visualization on button click instead of on load
        document.getElementById('visualize-btn').addEventListener('click', function() {
            const jsonInput = document.getElementById('json-input').value.trim();
            if (!jsonInput) {
                alert('Please paste JSON data in the textarea.');
                return;
            }
            
            try {
                const data = JSON.parse(jsonInput);
                // Clear existing visualization
                document.getElementById('visualization').innerHTML = '';
                // Create visualization with parsed data
                createVisualization(data);
            } catch (error) {
                console.error('Error parsing JSON:', error);
                alert('Invalid JSON format. Please check your input.');
            }
        });
        
        // Reset button functionality
        document.getElementById('reset-btn').addEventListener('click', function() {
            document.getElementById('json-input').value = '';
            document.getElementById('visualization').innerHTML = '';
        });

        function createVisualization(data) {
            // Set up dimensions
            const width = 1800;
            const height = 900;
            
            // Function to collapse node and all its children
            function collapse(d) {
                if (d.children) {
                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }
            }
            
            // Function to expand a node (only one level)
            function expand(d) {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
            }
            
            // Function to toggle node expansion state
            function toggleNode(d) {
                if (d.children) {
                    collapse(d);
                } else if (d._children) {
                    expand(d);
                }
                update(d);
            }
            
            // Create a hierarchy from the data
            const root = d3.hierarchy(data)
                .sum(d => 100) // Base size value for all nodes
                .sort((a, b) => b.value - a.value);
            
            // Collapse all retailers by default
            if (root.children) {
                root.children.forEach(collapse);
            }
            
            // Create the treemap layout
            const treemap = d3.treemap()
                .size([width, height])
                .paddingTop(28)
                .paddingRight(7)
                .paddingInner(3)
                .round(true);
                
            // Create SVG container
            const svg = d3.select("#visualization")
                .append("div")
                .style("position", "relative")
                .style("width", width + "px")
                .style("height", height + "px")
                .style("overflow", "hidden");
            
            // Create tooltip
            const tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);
            
            // Main update function for treemap
            function update(source) {
                // Compute the new treemap layout
                root.sum(d => {
                    // Dynamic sizing - more children makes bigger boxes
                    if (d.children || d._children) {
                        const count = (d.children ? d.children.length : 
                                     (d._children ? d._children.length : 0));
                        return 100 + count * 50;
                    }
                    return 100; // Base size for leaf nodes
                });
                
                treemap(root);
                
                // Select all existing nodes
                const nodes = svg.selectAll(".node")
                    .data(root.descendants(), d => d.id || (d.id = ++nodeId));
                
                // Remove exiting nodes
                nodes.exit().remove();
                
                // Enter new nodes
                const nodeEnter = nodes.enter()
                    .append("div")
                    .attr("class", d => {
                        let classNames = "node";
                        if (d.depth === 0) classNames += " root";
                        else if (d.depth === 1) classNames += " retailer";
                        else if (d.depth === 2) classNames += " virtualcatalogue";
                        else if (d.depth === 3) classNames += " network";
                        else classNames += " location";
                        
                        if (d.children || d._children) classNames += " node--has-children";
                        return classNames;
                    })
                    .style("left", d => d.x0 + "px")
                    .style("top", d => d.y0 + "px")
                    .style("width", d => Math.max(0, d.x1 - d.x0) + "px")
                    .style("height", d => Math.max(0, d.y1 - d.y0) + "px")
                    .style("opacity", 0)
                    .style("background-color", d => {
                        // Apply random but consistent colors to networks
                        if (d.depth === 3) { // Network level
                            return getNetworkColor(d.data.name);
                        }
                        return null; // Use CSS class color for other levels
                    })
                    .on("click", function(event, d) {
                        // Only toggle if node has children
                        if (d.children || d._children) {
                            event.stopPropagation();
                            toggleNode(d);
                        }
                    })
                    .on("mouseover", function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        
                        let tooltipContent = `<strong>${d.data.name}</strong>`;
                        if (d.data.ref) tooltipContent += `<br>Ref: ${d.data.ref}`;
                        if (d.data.type) tooltipContent += `<br>Type: ${d.data.type}`;
                        if (d.data.status) tooltipContent += `<br>Status: ${d.data.status}`;
                        
                        tooltip.html(tooltipContent)
                            .style("left", (event.pageX + 15) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                
                // Add node labels
                nodeEnter.append("div")
                    .attr("class", "node-label")
                    .style("left", "4px")
                    .style("top", "4px")
                    .style("width", d => Math.max(0, d.x1 - d.x0 - 10) + "px")
                    .text(d => d.data.name || "");
                
                // Add toggle indicators for nodes with children
                nodeEnter.filter(d => d.children || d._children)
                    .append("div")
                    .attr("class", "collapse-indicator")
                    .text(d => d.children ? "-" : "+");
                
                // Update all nodes
                const nodeUpdate = nodeEnter.merge(nodes);
                
                // Transition to new positions
                nodeUpdate.transition()
                    .duration(750)
                    .style("opacity", 1)
                    .style("left", d => d.x0 + "px")
                    .style("top", d => d.y0 + "px")
                    .style("width", d => Math.max(0, d.x1 - d.x0) + "px")
                    .style("height", d => Math.max(0, d.y1 - d.y0) + "px")
                    .style("background-color", d => {
                        // Apply random but consistent colors to networks
                        if (d.depth === 3) { // Network level
                            return getNetworkColor(d.data.name);
                        }
                        return null; // Use CSS class color for other levels
                    });
                
                // Update labels
                nodeUpdate.select(".node-label")
                    .style("width", d => Math.max(0, d.x1 - d.x0 - 10) + "px");
                
                // Update collapse indicators
                nodeUpdate.select(".collapse-indicator")
                    .text(d => d.children ? "-" : "+");
                
                // Transition exiting nodes
                nodes.exit()
                    .transition()
                    .duration(750)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Initialize counter for node IDs
            let nodeId = 0;
            
            // Initialize the visualization
            update(root);
            
            // Add zoom functionality
            function setupZoom() {
                const zoomContainer = d3.select("#visualization");
                let scale = 1;
                let translateX = 0;
                let translateY = 0;
                
                zoomContainer.on("wheel", function(event) {
                    event.preventDefault();
                    const delta = event.deltaY > 0 ? 0.9 : 1.1;
                    scale *= delta;
                    scale = Math.min(Math.max(0.5, scale), 3);
                    
                    svg.style("transform", `translate(${translateX}px, ${translateY}px) scale(${scale})`);
                });
                
                // Add pan functionality here if needed
            }
            
            setupZoom();
        }
    </script>
</body>
</html>